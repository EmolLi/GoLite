/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */

%{
#include <stdio.h>
#include <stdlib.h>

#include "tree.h"
#include "comm.h"

// Reference to the line number generated by the scanner
extern int yylineno;
// global g_tokens, tells scanner whether to emit (print) token info to stdout
enum modes mode;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// Root PROG node
extern PROG *root;

extern STMT *root_stmt;

extern EXP *root_exp;

/* typedef enum {false, true} bool; */

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
    if (mode == parse || pretty){
        fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
        fprintf(stderr,  "%s\n", yytext);
        exit(1);
    }
    else{
        while(yylex()){}
        }
}

%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */


 %code requires
 {
 }

%union {
    char *identifier;
    char *stringval;
    char runeval;
    int intval;
    double float64val;
    int boolval;
    struct PROG *prog;
    struct PACKAGE *package;
    struct DEC *dec;
    struct TYPE_SPEC *typeSpec;
    struct IDENTIFIER_LIST *id_list;
    struct VAR_SPEC *varspec;
    struct VAR_SPEC_LIST *varspec_list;
    struct PARAMETERS *parameters;
    struct STMT *stmt;
    struct STMT_LIST *stmt_list;
    struct CASE_CLAUSE *case_clause;
    struct CASE_CLAUSE_LIST *case_clause_list;
    struct FOR_CLAUSE *for_clause;
    struct EXP *exp;
    struct EXP_LIST *exp_list;
    struct TYPE *type;
    struct FIELD_DECL *fieldDecl;
};

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can be defined per directive by using a list
 * of identifiers separated by spaces.
 */


%type <prog> program

%type <package> package_declaration
%type <dec> topLevelDecls topLevelDecl declaration typeDecl varDecl functionDecl
%type <typeSpec> typeSpec typeSpecList
%type <varspec> varSpec varSpecList
%type <parameters> parameters
%type <stmt> statement stmt simpleStmt PostStmt returnStmt block switchStmt ifStmt elseStmt forStmt incDecStmt assignment shortVarDecl
%type <stmt_list> stmtList
%type <exp> expression orexpression andexpression relexpression addexpression multexpression unaryexpression primaryexpression literal
%type <exp_list> expList
%type <type> type
%type <fieldDecl> fieldDecl fieldDecls
%type <id_list> identifierList
%type <case_clause> exprCaseClause
%type <case_clause_list> exprCaseClauses
%type <for_clause> forClause


%token <intval> tINTVAL
%token <float64val> tFLOAT64VAL
%token <runeval> tRUNEVAL;
%token <stringval> tSTRINGVAL
%token <identifier> tIDENTIFIER

/* Go keywords not implemented in GoLite
go chan goto select map const fallthrough range import interface defer
*/

/* Types */
/* %token tINT tFLOAT64 tRUNE tSTRING tBOOL; */
%token tSTRUCT;

/* Declarations */
%token tVAR tTYPE tFUNC;

/* For/Switch Statement keywords */
%token tFOR tSWITCH tCASE tBREAK tCONTINUE tDEFAULT;

/* If/Else Statements */
%token tIF tELSE;

/* Other keywords */
%token tAPPEND;
%token tRETURN;
%token tPRINTLN tPRINT;

/* Included for backward-compatibility (not implemented) */
%token tPACKAGE;


/* binary operators has 5 precedence levels*/
/**
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
**/
%left tOR;
%left tAND;
%left tEQ tNEQ tLT tLEQ tGT tGEQ;
%left tPLUS tMINUS tBITOR tXOR;
%left tMULT tDIV tMOD tLSHIFT tRSHIFT tBITAND tBITCLEAR



/*     =       := */
%token tASSIGN tSHORTVARDEC

/*     +=      -=       *=      /=     %= */
%token tPLUSEQ tMINUSEQ tMULTEQ tDIVEQ tMODEQ

/*     ++   -- */
%token tINC tDEC


/*     &=        |=           &ˆ=         ˆ= */
%token tBITANDEQ tBITOREQ  tBITCLEAREQ tXOREQ
/*        <<=      >>= */
%token  tLSHIFTEQ tRSHIFTEQ


/*     (     )     [       ]       {       } */
%token tLPAR tRPAR tLBRACK tRBRACK tLBRACE tRBRACE
/*     ;        :    ,      . */
%token tSEMICOL tCOL tCOMMA tDOT



/* reserved not but supported keywords or operators */
%token tDEFER tGO tMAP tCHAN tGOTO tCONST tFALLTHROUGH tRANGE tINTERFACE tSELECT tIMPORT tLArrow tThreeDots
%left tBANG /* ! */
/* unary operators*/
/*           +      -      !     ˆ */
%precedence UPLUS UMINUS UBANG  UXOR



 /* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
  * operations. Tokens are grouped into precendence levels, with lower precedence coming first
  * and then higher precedence in later directives. Tokens specified in the same directive have
  * the same precedence. Ties at the same level are broken using either %left or %right, which
  * denote left-associative and right-associative respectively.
  */

 /* Start token (by default if this is missing it takes the first production */
%start program
/* %start expression */

 /* Generate the yylloc structure used for storing line numbers with tokens */
%locations
 /* Generate detailed error messages */
%error-verbose

%glr-parser
%expect-rr 1


 /* The second section of a bison file contains the productions. Note that rules with the
  * same LHS may be joined together and separated with a pipe.
  */
%%

program:
/* | statement {root_stmt = $1} */
/* expression {root_exp = $1;} */
package_declaration topLevelDecls { root = makeProgram($1, $2);}
;

package_declaration:
tPACKAGE tIDENTIFIER tSEMICOL{ $$ = makePackage($2);}
;

/*
Declaration   = TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl
*/

topLevelDecls: /* empty */  { $$ = NULL; }
| topLevelDecls topLevelDecl tSEMICOL { $$ = makeDecls($1, $2); }
;

topLevelDecl:
declaration { $$ = $1; }
| functionDecl { $$ = $1; }
;

declaration:
typeDecl  { $$ = $1; }
| varDecl { $$ = $1; }
;


/**
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
**/

varDecl:
tVAR varSpec { $$ = makeVarDecl($2); }
| tVAR tLPAR varSpecList tRPAR  { $$ = makeVarDecl($3); }   /* distribute var keyword */
;

varSpecList:
/* empty */ {}
| varSpecList varSpec tSEMICOL { $$ = insertVarSpecList($1, $2); }
;

varSpec:
identifierList type {$$ = makeVarSpec($1, $2, NULL);}
| identifierList type tASSIGN expList   {$$ = makeVarSpec($1, $2, $4);} /*check lhs.length = rhs.length when creating the AST*/
| identifierList tASSIGN expList    {$$ = makeVarSpec($1, NULL, $3);}
;



identifierList:
tIDENTIFIER  {$$ = makeIdentifierList(NULL, $1);}
| identifierList tCOMMA tIDENTIFIER  {$$ = makeIdentifierList($1, $3);}
;

/*
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec =  TypeDef .
*/
typeDecl: tTYPE typeSpec { $$ = makeTypeDecl($2);}
    | tTYPE tLPAR typeSpecList tRPAR    { $$ = makeTypeDecl($3);}
;

typeSpecList:   /* empty */     { $$ = NULL;}
    | typeSpecList typeSpec tSEMICOL    { $$ = makeTypeSpecList($1, $2);}
;

typeSpec: tIDENTIFIER type  { $$ = makeTypeSpec($2, $1); }
;

functionDecl:
tFUNC tIDENTIFIER tLPAR parameters tRPAR type block {$$ = makeFunction($2, $4, $7, $6);}     /** TODO: weed look for return statement **/
| tFUNC tIDENTIFIER tLPAR parameters tRPAR block {$$ = makeFunction($2, $4, $6, NULL);}
;



parameters:
/* empty */ {$$ = NULL;}
| identifierList type   {$$ = makeParameters(NULL, $1, $2);}
| parameters tCOMMA identifierList type { $$ = makeParameters($1, $3, $4);}
;



/*                  statement                  */
/** TODO: test semicolon insertion in scanner **/
/*
Declaration | SimpleStmt | ReturnStmt | BreakStmt | ContinueStmt |
Block | IfStmt | SwitchStmt | SelectStmt | forStmt |
*/
statement :
declaration {$$ = makeDeclareStmt($1);}
| simpleStmt   {$$ = $1;}
| returnStmt   {$$ = $1;}
| tBREAK     {$$ = makeBreakStmt();}  /*TODO: weed*/
| tCONTINUE  {$$ = makeContinueStmt();}
| block {$$ = $1;}
| switchStmt    {$$ = $1;}
| forStmt       {$$ = $1;}
| tPRINT tLPAR expList tRPAR      {$$ = makePrintStmt($3);}
| tPRINT tLPAR tRPAR      {$$ = makePrintStmt(NULL);}
| tPRINTLN tLPAR expList tRPAR      {$$ = makePrintlnStmt($3);}
| tPRINTLN tLPAR tRPAR      {$$ = makePrintlnStmt(NULL);}
| ifStmt            {$$ = $1;}
;



/** TODO:
**/
/*
forStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
*/
forStmt:
tFOR block {$$ = makeForStmt(NULL, NULL, $2);}
| tFOR expression block {$$ = makeForStmt($2, NULL, $3);}
| tFOR forClause block {$$ = makeForStmt(NULL, $2, $3);}
;

/* [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] */
forClause:
simpleStmt tSEMICOL expression tSEMICOL PostStmt   {$$ = makeForClause($1, $3, $5);}
| simpleStmt tSEMICOL expression tSEMICOL    {$$ = makeForClause($1, $3, NULL);}
| simpleStmt tSEMICOL tSEMICOL PostStmt   {$$ = makeForClause($1, NULL, $4);}
| simpleStmt tSEMICOL tSEMICOL    {$$ = makeForClause($1, NULL, NULL);}
;

PostStmt:
incDecStmt    {$$ = $1;}
| assignment    {$$ = $1;}
;

returnStmt:
tRETURN        {$$ = makeReturnStmt(NULL);}     /* return zero exp */
| tRETURN expression       {$$ = makeReturnStmt($2);}   /* return one exp */

block:
tLBRACE stmtList tRBRACE         {$$ = makeBlockStmt($2);}
|tLBRACE tRBRACE        {$$ = makeBlockStmt(NULL);}
;


/* Emptytmt | ExpressionStmt  | IncDecStmt | Assignment | ShortVarDecl  */
simpleStmt:
 {$$ = makeEmptyStmt(); }
| expression   {$$ = makeExpStmt($1);}   /* check if it's proper expStmt in tree.c (only function calls allowed)*/
| incDecStmt   {$$ = $1;}
| assignment   {$$ = $1;}
| shortVarDecl  {$$ = $1;}
;

incDecStmt:
expression tINC   {$$ = makeIncStmt($1);}
| expression tDEC   {$$ = makeDecStmt($1);}
;

ifStmt:
tIF simpleStmt tSEMICOL expression block elseStmt {$$ = makeIfStmt($2, $4, $5, $6);}
| tIF simpleStmt tSEMICOL expression block {$$ = makeIfStmt($2, $4, $5, NULL);}
| tIF expression block elseStmt {$$ = makeIfStmt(NULL, $2, $3, $4);}
| tIF expression block {$$ = makeIfStmt(NULL, $2, $3, NULL);}
;

elseStmt:
tELSE ifStmt {$$ = makeElseStmt($2);}
| tELSE block {$$ = makeElseStmt($2);}
;

assignment: /* for op assign, only single id and single exp is supported*/
expression tPLUSEQ expression    {$$ = makeAssignOpStmt(pluseq, $1, $3);}
| expression tMINUSEQ expression    {$$ = makeAssignOpStmt(minuseq, $1, $3);}
| expression tBITOREQ expression    {$$ = makeAssignOpStmt(bitoreq, $1, $3);}
| expression tXOREQ expression    {$$ = makeAssignOpStmt(xoreq, $1, $3);}
| expression tMULTEQ expression   {$$ = makeAssignOpStmt(multeq, $1, $3);}
| expression tDIVEQ expression   {$$ = makeAssignOpStmt(diveq, $1, $3);}
| expression tMODEQ expression   {$$ = makeAssignOpStmt(modeq, $1, $3);}
| expression tLSHIFTEQ expression   {$$ = makeAssignOpStmt(lshifteq, $1, $3);}
| expression tRSHIFTEQ expression   {$$ = makeAssignOpStmt(rshifteq, $1, $3);}
| expression tBITANDEQ expression   {$$ = makeAssignOpStmt(bitandeq, $1, $3);}
| expression tBITCLEAREQ expression   {$$ = makeAssignOpStmt(bitcleareq, $1, $3);}
| expList tASSIGN expList   {$$ = makeAssignStmt($1, $3);}  /* TODO: weeding check lexpList.size == rexpList.size and explist.size > 0*/
;


/**
addOP : tPLUSEQ {}
    | tMINUS    {}
    | tBITOR    {}
    | tXOR      {}
;

mulOp : tMULT   {}
    | tDIV      {}
    | tMOD      {}
    | tLSHIFT   {}
    | tRSHIFT   {}
    | tBITAND   {}
    | tBITCLEAR {}

**/
expList: expList tCOMMA expression  {$$ = insertExpList($1, $3);}
| expression {$$ = makeExpList($1);}
;

stmtList :
stmtList stmt    {$$ = insertStmtList($1, $2);}
| stmt {$$ = makeStmtList($1);}
;

stmt:
statement tSEMICOL    { $$ = $1;}
;

shortVarDecl:
identifierList tSHORTVARDEC expList {$$ = makeShortdecStmt($1, $3);}
;

/*
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList | "default" .
*/
switchStmt:
tSWITCH simpleStmt tSEMICOL expression tLBRACE exprCaseClauses tRBRACE  {$$ = makeSwitchStmt($2, $4, $6);}
| tSWITCH simpleStmt tSEMICOL tLBRACE exprCaseClauses tRBRACE  {$$ = makeSwitchStmt($2, NULL, $5);}
| tSWITCH expression tLBRACE exprCaseClauses tRBRACE  {$$ = makeSwitchStmt(NULL, $2, $4);}
| tSWITCH tLBRACE exprCaseClauses tRBRACE  {$$ = makeSwitchStmt(NULL, NULL, $3);}
| tSWITCH tLBRACE tRBRACE  {$$ = makeSwitchStmt(NULL, NULL, NULL);}
;

exprCaseClauses:
exprCaseClauses exprCaseClause {$$ = insertCaseClauseList($1, $2);}
| exprCaseClause {$$ = makeCaseClauseList($1);}
;

exprCaseClause:
tCASE expList tCOL stmtList {$$ = makeCaseClause($2, $4);}
| tCASE expList tCOL {$$ = makeCaseClause($2, NULL);}
| tDEFAULT tCOL stmtList    {$$ = makeDefaultClause($3);}
| tDEFAULT tCOL  {$$ = makeDefaultClause(NULL);}
;



/*          Expression               */
expression :
orexpression { $$ = $1;}
;

orexpression : andexpression {$$ = $1;}
             | orexpression tOR andexpression   {$$ = makeBinaryExp(orK, $1, $3);}
;

andexpression : relexpression {$$ = $1;}
              | andexpression tAND relexpression {$$ = makeBinaryExp(andK, $1, $3);}
;

relexpression :
relexpression tEQ addexpression   {$$ = makeBinaryExp(eqK, $1, $3);}
| relexpression tNEQ addexpression  {$$ = makeBinaryExp(neqK, $1, $3);}
| relexpression tLT addexpression {$$ = makeBinaryExp(ltK, $1, $3);}
| relexpression tGT addexpression {$$ = makeBinaryExp(gtK, $1, $3);}
| relexpression tLEQ addexpression {$$ = makeBinaryExp(leqK, $1, $3);}
| relexpression tGEQ addexpression {$$ = makeBinaryExp(geqK, $1, $3);}
| addexpression {$$ = $1;}
;


addexpression :
addexpression tPLUS multexpression  {$$ = makeBinaryExp(plusK, $1, $3);}
| addexpression tMINUS multexpression  {$$ = makeBinaryExp(minusK, $1, $3);}
| addexpression tBITOR multexpression  {$$ = makeBinaryExp(bitorK, $1, $3);}
| addexpression tXOR multexpression  {$$ = makeBinaryExp(xorK, $1, $3);}
| multexpression {$$ = $1;}
;


multexpression : unaryexpression {$$ = $1; }
               | multexpression tMULT unaryexpression {$$ = makeBinaryExp(multK, $1, $3);}
               | multexpression tDIV unaryexpression {$$ = makeBinaryExp(divideK, $1, $3);}
               | multexpression tMOD unaryexpression {$$ = makeBinaryExp(modK, $1, $3);}
               | multexpression tLSHIFT unaryexpression {$$ = makeBinaryExp(lshiftK, $1, $3);}
               | multexpression tRSHIFT unaryexpression {$$ = makeBinaryExp(rshiftK, $1, $3);}
               | multexpression tBITAND unaryexpression {$$ = makeBinaryExp(bitandK, $1, $3);}
               | multexpression tBITCLEAR unaryexpression {$$ = makeBinaryExp(bitclearK, $1, $3);}

/* + - ! ˆ */
unaryexpression : primaryexpression         {$$ = $1;}
| tMINUS unaryexpression   %prec UMINUS {$$ = makeUnaryExp(uminusK, $2);}
| tPLUS unaryexpression    %prec UPLUS {$$ = makeUnaryExp(uplusK, $2);}
| tBANG unaryexpression    %prec UBANG {$$ = makeUnaryExp(ubangK, $2);}
| tXOR unaryexpression    %prec UXOR {$$ = makeUnaryExp(uxorK, $2);}
;


primaryexpression : literal     {$$ = $1;}
| tIDENTIFIER  {$$ = makeIdentifierExp($1);}
| tLPAR expression tRPAR  {$$ = $2;}
| tAPPEND tLPAR expression tCOMMA expression tRPAR {$$ = makeAppendExp($3, $5);}
| primaryexpression tLPAR expList tRPAR    {$$ = makeFuncExp($1, $3);}  /* func call or cast (with alias)*/
| primaryexpression tLPAR tRPAR    {$$ = makeFuncExp($1, NULL);}  /* func call or cast (with alias)*/
| primaryexpression tLBRACK expression tRBRACK  {$$ = makeArrayIndexExp($1, $3);} /* array or slice item e.g.a[1]*/
| primaryexpression tDOT tIDENTIFIER { $$ = makeStructAccessExp($1, $3); }    /* struct attribute */
;


literal : tFLOAT64VAL   {$$ = makeFloat64Exp($1);}
| tINTVAL   {$$ = makeIntExp($1);}
| tRUNEVAL  {$$ = makeRuneExp($1);}
| tSTRINGVAL    {$$ = makeStringExp($1);}
    /*| tNULL
          {$$ = makeEXPnull();}*/
;



type :   tLPAR type tRPAR    { $$ = $2; }
        /* basic types */
    | tIDENTIFIER   {$$ = makeType($1);}  /* struct TODO: check if the identifier is a type (maybe in weeding phase)*/
        /* struct */
    | tSTRUCT tLBRACE fieldDecls tRBRACE   {$$ = makeStructType($3);}
        /* slices */
    | tLBRACK tRBRACK type  {$$ = makeSliceType($3);}/* slices e.g.[]int */
        /* array */
    | tLBRACK tINTVAL tRBRACK type  {$$ = makeArrayType($4, $2);}/* array e.g [1]int*/
;


fieldDecls: /* empty */ {$$ = NULL;}
    | fieldDecls fieldDecl tSEMICOL    {$$ = insertFieldDeclList($1, $2);}
;

fieldDecl:
    identifierList type {$$ = makeFieldDecl($1, $2);}
;
/*
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
*/

/*
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit
*/



/*
cast_or_expr   : '(' IDENTIFIER ')'
               ;
cast           : cast_or_expr
               | '(' type ')'
               ;
expr_except_id : cast_or_expr
               | cast expression %prec CAST
               | '(' expr_except_id ')'
               | expression '=' expression
               ;
expression     : IDENTIFIER
               | expr_except_id
               ;
*/


%%
